import pandas as pd
import numpy as np

# Load dataset
df = pd.read_csv('Book1_small.csv')

# Convert date columns to datetime
df['ACCT_OPN_DT'] = pd.to_datetime(df['ACCT_OPN_DT'], format='%d/%m/%y', errors='coerce')
df['REPORT_DT'] = pd.to_datetime(df['REPORT_DT'], format='%d/%m/%y', errors='coerce')
df['LST_CUST_CR_DT'] = pd.to_datetime(df['LST_CUST_CR_DT'], format='%d/%m/%y', errors='coerce')
df['LST_CUST_DR_DT'] = pd.to_datetime(df['LST_CUST_DR_DT'], format='%d/%m/%y', errors='coerce')

# Filter for 'SA' accounts
df_sa = df[df['PF_FAC_REPT'] == 'SA'].copy()

# Handle tier columns
tier_cols = ['ROHDIUM', 'PLATINUM', 'DIAMOND', 'GOLD', 'SILVER']
tier_priority = {'ROHDIUM': 5, 'PLATINUM': 4, 'DIAMOND': 3, 'GOLD': 2, 'SILVER': 1}

# Create tier score for each account
df_sa['tier_score'] = df_sa[tier_cols].dot([tier_priority[col] for col in tier_cols])

# Define aggregation dictionary
agg_dict = {
    'CUST_CLASS': lambda x: x.loc[df_sa.loc[x.index, 'tier_score'].idxmax()],  # Select CUST_CLASS with highest tier
    'CUST_CAT': lambda x: x.mode()[0] if not x.mode().empty else 'Unknown',  # Most frequent CUST_CAT
    'SALARY': 'max',
    'STAFF': 'max',
    'NRI': 'max',
    'AGRI': 'max',
    'SME': 'max',
    'SBF': 'max',
    'SSI': 'max',
    'END_OF_DAY_BAL': 'sum',
    'AVG_BAL_MTD': 'sum',
    'AVG_BAL_QTD': 'sum',
    'AVG_BAL_YTD': 'sum',
    'AQB': 'sum',
    'TDV': 'sum',
    'DR_AMT': 'sum',
    'CR_AMT': 'sum',
    'DR_NO': 'sum',
    'CR_NO': 'sum',
    'SAVINGS_BANK': 'max',
    'FD': 'max',
    'RD': 'max',
    'PERSONAL_LOAN': 'max',
    'HOME_LOAN': 'max',
    'CAR_LOAN': 'max',
    'TWO_WHEELER': 'max',
    'EDUCATION_LOAN': 'max',
    'GOLD_LOAN': 'max',
    'AGRI_LOAN': 'max',
    'SME_LOAN': 'max',
    'HOME_LOAN_AMT': 'sum',
    'SBI_MF': 'max',
    'SBI_CAP': 'max',
    'SBI_CARD': 'max',
    'SBI_LFE': 'max',
    'SBI_GNRL': 'max',
    'APY': 'max',
    'NPS': 'max',
    'PMJJY': 'max',
    'PMSBY': 'max',
    'ATM': 'max',
    'MBS': 'max',
    'YONO': 'max',
    'UPI': 'max',
    'INB': 'max',
    'LOCKER': 'max',
    'TOTAL_PRODUCT': 'sum',
    'TOTAL_PRODUCT_EXCL_SERVICES': 'sum',
    'JNT_ACCT_FLG': lambda x: 'Y' if 'Y' in x.values else 'N',  # Any account with joint flag
    'ACCT_OPN_DT': 'min',
    'LST_CUST_CR_DT': 'max',
    'LST_CUST_DR_DT': 'max',
    'REPORT_DT': 'max'
}

# Aggregate to customer level
df_customer = df_sa.groupby('CUST_NBR').agg(agg_dict).reset_index()

# Handle missing values
numerical_cols = df_customer.select_dtypes(include=['float64', 'int64']).columns
df_customer[numerical_cols] = df_customer[numerical_cols].fillna(df_customer[numerical_cols].median())
df_customer['CUST_CLASS'] = df_customer['CUST_CLASS'].fillna(df_customer['CUST_CLASS'].mode()[0])
df_customer['CUST_CAT'] = df_customer['CUST_CAT'].fillna(df_customer['CUST_CAT'].mode()[0])
df_customer['JNT_ACCT_FLG'] = df_customer['JNT_ACCT_FLG'].fillna('N')

# Feature engineering
reference_date = pd.to_datetime('2025-06-30')
df_customer['TENURE_DAYS'] = (reference_date - df_customer['ACCT_OPN_DT']).dt.days
df_customer['AVG_DR_AMT'] = df_customer['DR_AMT'] / df_customer['DR_NO'].replace(0, 1)
df_customer['AVG_CR_AMT'] = df_customer['CR_AMT'] / df_customer['CR_NO'].replace(0, 1)
df_customer['DAYS_SINCE_LAST_CR'] = (reference_date - df_customer['LST_CUST_CR_DT']).dt.days
df_customer['DAYS_SINCE_LAST_DR'] = (reference_date - df_customer['LST_CUST_DR_DT']).dt.days
df_customer['net_flow_amt'] = df_customer['CR_AMT'] - df_customer['DR_AMT']
df_customer['balance_utilization'] = (df_customer['DR_AMT'] + df_customer['CR_AMT']) / (df_customer['AVG_BAL_YTD'] + 1e-6)
df_customer['peak_balance_ratio'] = df_customer['END_OF_DAY_BAL'] / (df_customer['AVG_BAL_YTD'] + 1e-6)
df_customer['product_diversity'] = df_customer[['SAVINGS_BANK', 'FD', 'RD', 'PERSONAL_LOAN', 'HOME_LOAN', 'SBI_MF', 'UPI', 'INB']].gt(0).sum(axis=1) / 8
df_customer['loan_to_investment'] = df_customer[['PERSONAL_LOAN', 'HOME_LOAN']].sum(axis=1) / (df_customer[['FD', 'RD', 'SBI_MF']].sum(axis=1) + 1e-6)
df_customer['digital_to_physical'] = df_customer[['MBS', 'YONO', 'UPI', 'INB']].sum(axis=1) / (df_customer[['ATM', 'LOCKER']].sum(axis=1) + 1e-6)
df_customer['agri_activity_flag'] = ((df_customer['AGRI'] == 1) & (df_customer['AGRI_LOAN'] > 0)).astype(int)
df_customer['JNT_ACCT_FLG_NUM'] = df_customer['JNT_ACCT_FLG'].map({'Y': 2, 'N': 1})
df_customer['joint_adjusted_dr_amt'] = df_customer['DR_AMT'] / df_customer['JNT_ACCT_FLG_NUM']
df_customer['days_since_last_txn'] = df_customer[['DAYS_SINCE_LAST_CR', 'DAYS_SINCE_LAST_DR']].max(axis=1)
df_customer['dormancy_risk'] = (df_customer['days_since_last_txn'] > 90).astype(int)
df_customer['product_adoption_rate'] = df_customer['TOTAL_PRODUCT'] / (df_customer['TENURE_DAYS'] / 365 + 1e-6)
df_customer['product_balance_interaction'] = df_customer['TOTAL_PRODUCT'] * df_customer['AVG_BAL_YTD']
df_customer['tenure_txn_interaction'] = df_customer['TENURE_DAYS'] * (df_customer['DR_NO'] + df_customer['CR_NO'])

# Digital Engagement
digital_features = ['ATM', 'MBS', 'YONO', 'UPI', 'INB']
base_weights_digital = {'INB': 5, 'YONO': 4, 'MBS': 3, 'UPI': 2, 'ATM': 1}
overall_usage_digital = df_customer[digital_features].mean()
tier_usage_digital = df_customer.groupby('CUST_CLASS')[digital_features].mean()
weights_digital = {}
for tier in tier_usage_digital.index:
    weights_digital[tier] = {}
    for feature in digital_features:
        weights_digital[tier][feature] = base_weights_digital[feature] * (tier_usage_digital.loc[tier, feature] / (overall_usage_digital[feature] + 0.01))

def compute_digital_engagement(row):
    tier = row['CUST_CLASS']
    score = 0
    for feature in digital_features:
        if row[feature] == 1:
            score += weights_digital[tier][feature]
    return score

df_customer['digital_engagement'] = df_customer.apply(compute_digital_engagement, axis=1)

# Transaction Score
transaction_features = ['DR_AMT', 'CR_AMT']
base_weights_transaction = {'DR_AMT': 1, 'CR_AMT': 1}
overall_usage_transaction = df_customer[transaction_features].mean()
tier_usage_transaction = df_customer.groupby('CUST_CLASS')[transaction_features].mean()
weights_transaction = {}
for tier in tier_usage_transaction.index:
    weights_transaction[tier] = {}
    for feature in transaction_features:
        weights_transaction[tier][feature] = base_weights_transaction[feature] * (tier_usage_transaction.loc[tier, feature] / (overall_usage_transaction[feature] + 0.01))

def compute_transaction_score(row):
    tier = row['CUST_CLASS']
    score = 0
    for feature in transaction_features:
        score += weights_transaction[tier][feature] * row[feature]
    return score

df_customer['transaction_score'] = df_customer.apply(compute_transaction_score, axis=1)

# Product Score
product_features = ['FD', 'RD', 'PERSONAL_LOAN', 'HOME_LOAN']
base_weights_product = {'FD': 3, 'RD': 2, 'PERSONAL_LOAN': 4, 'HOME_LOAN': 5}
overall_usage_product = df_customer[product_features].mean()
tier_usage_product = df_customer.groupby('CUST_CLASS')[product_features].mean()
weights_product = {}
for tier in tier_usage_product.index:
    weights_product[tier] = {}
    for feature in product_features:
        weights_product[tier][feature] = base_weights_product[feature] * (tier_usage_product.loc[tier, feature] / (overall_usage_product[feature] + 0.01))

def compute_product_score(row):
    tier = row['CUST_CLASS']
    score = 0
    for feature in product_features:
        if row[feature] == 1:
            score += weights_product[tier][feature]
    return score

df_customer['product_score'] = df_customer.apply(compute_product_score, axis=1)

# Save the enhanced dataset
df_customer.to_csv('customer_level_high_value_sa_dataset.csv', index=False)
