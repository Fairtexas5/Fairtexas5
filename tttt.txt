features_digital = [
    'DIGITAL_ENGAGE', 'DIGI_TO_PHYS'
]

features_balance_dynamics = [
    'BAL_STAB', 'BAL_GTH_IND', 'MTH_BAL_TREND', 'BAL_UTIL', 'NET_FLOW_AMT', 'NET_FLOW_RATIO'
]

features_relationship = [
    'TOTAL_PRODUCT', 'TOTAL_PRODUCT_EXCL_SERVICES', 'PRODUCT_SCORE', 'PROD_DIVERSITY',
    'RELATION_DEPTH', 'PREM_BANK', 'CROSS_SELL_SUCCESS', 'PROD_BAL_INTERACT'
]

features_risk_dormancy = [
    'DORM_RISK', 'SEV_DORM_RISK', 'DAY_SINCE_LST_TXN', 'DAYS_SINCE_LAST_CR', 'DAYS_SINCE_LAST_DR'
]

features_growth_consistency = [
    'NEFT_CNT_GROWTH', 'RTGS_CNT_GROWTH', 'RTGS_AMT_GROWTH',
    'NEFT_CONSISTENCY', 'RTGS_CONSISTENCY'
]








import pandas as pd
from scipy.stats import mode

# Assuming your DataFrame is 'df' and cluster labels in 'KmeansCluster'

# Feature groups
features_txn = [
    'TDV', 'TOTAL_NEFT_DR_AMT', 'TOTAL_NEFT_CNT', 'TOTAL_NEFT_AMT',
    'TOTAL_RTGS_DR_CNT', 'TOTAL_RTGS_CNT', 'TOTAL_RTGS_AMT',
    'NEFT_AVG_TXN_VALUE', 'RTGS_AVG_TXN_VALUE', 'TXN_FREQ',
    'AVG_DR_AMT', 'AVG_CR_AMT', 'NET_FLOW_AMT', 'NET_FLOW_RATIO'
]

features_balance = [
    'AQB', 'BAL_STAB', 'BAL_GTH_IND', 'MTH_BAL_TREND', 'NET_FLOW_AMT', 'BAL_UTIL'
]

features_profile = [
    'TENURE_DAYS', 'PRODUCT_SCORE', 'TOTAL_PRODUCT',
    'TOTAL_PRODUCT_EXCL_SERVICES', 'RELATION_DEPTH', 'PREM_BANK',
    'PROD_DIVERSITY', 'CROSS_SELL_SUCCESS'
]

features_digital = [
    'DIGITAL_ENGAGE', 'DIGI_TO_PHYS'
]

features_balance_dynamics = [
    'BAL_STAB', 'BAL_GTH_IND', 'MTH_BAL_TREND', 'BAL_UTIL', 'NET_FLOW_AMT', 'NET_FLOW_RATIO'
]

features_relationship = [
    'TOTAL_PRODUCT', 'TOTAL_PRODUCT_EXCL_SERVICES', 'PRODUCT_SCORE', 'PROD_DIVERSITY',
    'RELATION_DEPTH', 'PREM_BANK', 'CROSS_SELL_SUCCESS', 'PROD_BAL_INTERACT'
]

features_risk_dormancy = [
    'DORM_RISK', 'SEV_DORM_RISK', 'DAY_SINCE_LST_TXN', 'DAYS_SINCE_LAST_CR', 'DAYS_SINCE_LAST_DR'
]

# Combine all features to check mode safely
all_features = list(set(
    features_txn + features_balance + features_profile + features_digital +
    features_balance_dynamics + features_relationship + features_risk_dormancy
))

# Function to calculate mode per cluster (returns mode's value)
def cluster_mode(df, features, cluster_col='KmeansCluster'):
    mode_df = pd.DataFrame()
    for cluster in sorted(df[cluster_col].unique()):
        cluster_data = df[df[cluster_col] == cluster][features]
        # axis=0 computes mode along each column
        modes = cluster_data.mode().iloc[0]  # mode() returns a dataframe, take first row of mode
        modes.name = cluster
        mode_df = pd.concat([mode_df, modes], axis=1)
    return mode_df.T  # Transpose so clusters are rows

# Prepare containers for results
summary_stats = {}

groups = {
    'Transaction Features': features_txn,
    'Balance & Loyalty': features_balance,
    'Customer Profile': features_profile,
    'Digital Engagement': features_digital,
    'Balance Dynamics': features_balance_dynamics,
    'Relationship Features': features_relationship,
    'Risk & Dormancy': features_risk_dormancy
}

for group_name, feature_list in groups.items():
    print(f"\n--- {group_name} ---")

    # Mean
    mean_df = df.groupby('KmeansCluster')[feature_list].mean()
    print(f"\nMean values by cluster:\n", mean_df)

    # Median
    median_df = df.groupby('KmeansCluster')[feature_list].median()
    print(f"\nMedian values by cluster:\n", median_df)

    # Mode
    mode_df = cluster_mode(df, feature_list, cluster_col='KmeansCluster')
    print(f"\nMode values by cluster:\n", mode_df)

    # Store results if desired
    summary_stats[group_name] = {
        'mean': mean_df,
        'median': median_df,
        'mode': mode_df
    }
