# --- Step 4: Account-Level Feature Engineering ---
print("Step 4: Computing engagement scores...")

# Define feature groups
digital_features = ['ATM', 'MBS', 'YONO', 'UPI', 'INB']
transaction_features = ['DR_AMT', 'CR_AMT']
product_features = ['FD', 'RD', 'PERSONAL_LOAN', 'HOME_LOAN']

# Filter to only existing columns
digital_features = [f for f in digital_features if f in df_sb.columns]
transaction_features = [f for f in transaction_features if f in df_sb.columns]
product_features = [f for f in product_features if f in df_sb.columns]

# Define base weights
base_weights = {
    'INB': 5.0, 'YONO': 4.0, 'MBS': 3.0, 'UPI': 2.0, 'ATM': 1.0,
    'DR_AMT': 1.0, 'CR_AMT': 1.0,
    'FD': 3.0, 'RD': 2.0, 'PERSONAL_LOAN': 4.0, 'HOME_LOAN': 5.0
}

# Calculate engagement scores using vectorized operations
# Digital engagement score
if digital_features:
    df_sb['DIGITAL_ENGAGE'] = sum(df_sb[f].fillna(0) * base_weights.get(f, 1.0) for f in digital_features)
else:
    df_sb['DIGITAL_ENGAGE'] = 0.0

# Transaction score
if transaction_features:
    df_sb['TRANSACTION_SCORE'] = sum(df_sb[f].fillna(0) * base_weights.get(f, 1.0) for f in transaction_features)
else:
    df_sb['TRANSACTION_SCORE'] = 0.0

# Product score
if product_features:
    df_sb['PRODUCT_SCORE'] = sum(df_sb[f].fillna(0) * base_weights.get(f, 1.0) for f in product_features)
else:
    df_sb['PRODUCT_SCORE'] = 0.0

print(f"Engagement scores computed for {len(df_sb)} accounts")

# --- Step 5: Customer-Level Aggregation ---
print("Step 5: Aggregating to customer level...")

# Check if CUST_NBR exists
if 'CUST_NBR' not in df_sb.columns:
    print("Error: 'CUST_NBR' column not found")
    df_customer = pd.DataFrame()
else:
    # Define column groups for aggregation
    service_cols = ['SBI_CARD', 'SBI_LFE', 'SBI_GNRL', 'APY', 'PMJJY', 'PMSBY']
    product_cols = ['SALARY', 'STAFF', 'NRI', 'AGRI', 'SME', 'SBF', 'SSI',
                    'SAVINGS_BANK', 'FD', 'RD', 'PERSONAL_LOAN', 'HOME_LOAN',
                    'CAR_LOAN', 'EDUCATION_LOAN', 'GOLD_LOAN', 'AGRI_LOAN',
                    'SBI_MF', 'SBI_CAP', 'ATM', 'MBS', 'YONO', 'UPI', 'INB',
                    'LOCKER', 'ROHDIUM', 'PLATINUM', 'DIAMOND', 'GOLD', 'SILVER']
    
    balance_cols = ['END_OF_DAY_BAL', 'AVG_BAL_MTD', 'AVG_BAL_QTD', 'AVG_BAL_YTD',
                    'AQB', 'TDV', 'DR_AMT', 'CR_AMT', 'DR_NO', 'CR_NO',
                    'HOME_LOAN_AMT', 'DIGITAL_ENGAGE', 'TRANSACTION_SCORE',
                    'PRODUCT_SCORE']
    
    date_cols = ['ACCT_OPN_DT', 'REPORT_DT', 'LST_CUST_CR_DT', 'LST_CUST_DR_DT']
    
    # Filter to existing columns
    service_cols = [col for col in service_cols if col in df_sb.columns]
    product_cols = [col for col in product_cols if col in df_sb.columns]
    balance_cols = [col for col in balance_cols if col in df_sb.columns]
    date_cols = [col for col in date_cols if col in df_sb.columns]
    
    # Calculate tenure if possible
    if 'ACCT_OPN_DT' in df_sb.columns and 'REPORT_DT' in df_sb.columns:
        df_sb['TENURE_DAYS'] = (df_sb['REPORT_DT'] - df_sb['ACCT_OPN_DT']).dt.days
        df_sb['TENURE_DAYS'] = df_sb['TENURE_DAYS'].fillna(0).clip(lower=0)
        balance_cols.append('TENURE_DAYS')
    
    # Create aggregation dictionary using dictionary comprehension
    agg_dict = {
        # Categorical columns - most frequent value
        **{col: lambda x: x.mode().iloc[0] if len(x.mode()) > 0 else 'Unknown' 
           for col in ['CUST_CLASS', 'CUST_CAT', 'JNT_ACCT_FLG'] if col in df_sb.columns},
        
        # Product/service columns - maximum (binary flags)
        **{col: 'max' for col in service_cols + product_cols},
        
        # Balance/amount columns - sum
        **{col: 'sum' for col in balance_cols},
        
        # Date columns - specific aggregation
        **{col: agg_type for col, agg_type in {
            'ACCT_OPN_DT': 'min', 'REPORT_DT': 'max', 
            'LST_CUST_CR_DT': 'max', 'LST_CUST_DR_DT': 'max', 
            'TENURE_DAYS': 'max'
        }.items() if col in df_sb.columns}
    }
    
    # Perform aggregation
    df_customer = df_sb.groupby('CUST_NBR').agg(agg_dict).reset_index()
    
    # Clean up data types using vectorized operations
    numeric_cols = [col for col in balance_cols if col in df_customer.columns]
    df_customer[numeric_cols] = df_customer[numeric_cols].apply(pd.to_numeric, errors='coerce').fillna(0)
    
    print(f"Customer aggregation complete: {len(df_customer)} customers with {len(df_customer.columns)} features")
